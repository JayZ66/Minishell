
- exit => OK
- ctrl + c => OK
- < end.txt wc -l < file.txt cat
=> Error to handle
- echo '"SALUT'"
=> Quotes are not closed, error to manage
- entree => OK
- Que des espaces : OK
=> Devrait renvoyer a la ligne.
TO TEST : DONE
$> echo hola > bonjour
$> echo hey > hello
$> <bonjour >hello
$> cat bonjour 
$> cat hello

cat > ok 
...
...
cat < ok => DONE
- Gestion env + update => DONE


- > - | - < - \ 
=> Erreurs a gerer pour arreter le prog.

- Minishell>$echo -nnn ------------------n
malloc(): corrupted top size

- echo >< | echo > < + gestion | | + etc.
=> SEGFAULT
Gerer les erreurs de syntaxe !

- $VAR.ENV.:
Check dans la tokenisation > Checker dans la string : 
1. tant que str & que pas $
2. puis que pas autre $
3. Check si var. d'env. 
4. On modifie

- Try a command like : echo "cat lol.c | cat > lol.c"
=> Need to put things inside quotes in a node (like option)
& not creating different nodes.
- Absolute path => Check how to manage it

- REVOIR FONCTION QUOTES ! => OK ?
On avance de gauche a droite > On check chaque quote,
si un niveau de quote on retire, sinon d'autres dedans,
on affiche ce qu'il y a l'interieur.

Quand guillemets tu ouvres, puis
si meme guillemets et rien avant > on ouvre.
Sinon si meme guillemets > Ferme et i--;
Sinon, on ajoute le texte : 
si i != 0, pb de guillemets.

- Absolute path : 
Checker si abolute path : Si je rencontre un slash alors absolute path !
On va pas chercher le path, on l'envoie direct a execve.

- Quotes avec $ => Pas besoin des doubles quote pour
avoir la var. d'env.
Par contre, si ne trouve pas => Retire le bout.
=> Gerer dans le parsing : 
- Si tu trouves double quotes & 

JEZA : TO DO
- Gerer echo SALUT > OK | cat OK => OK with check_line function because
i'm waiting for each block, so the end of each cmd, then cat can access to ok file.
=> So how to do it ??
- Tester de nouveau les file seuls ! + voir pour append/output or else.
=> OK : i'm can now verify if there is one file if it exists or not.
=> BUT it's not totally good bce if i have a file & then a pipe, ça
fait la redirection du file sur STDOUT ce qui fait qu'il envoie les données à
cat alors que normalement cat ne reçoit rien.
idée : créer une autre fonction d'output pour l'output seul. => OK



< ok | cat / wc => why send it to the cmd ? => DONE

<< end | cat => OK
cat | < end.txt => SEGFAULT
Checker parsing & execution => Invalid read of size.